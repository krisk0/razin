Installation
============

With portage package manager: 
 put python-sage-flint-20140310.ebuild into /your/private/overlay/dev-python/python-sage-flint
 
 move 2014xyzw-rv.zip to /distfiles/razin-2014xyzw-rv.zip, if you don't want to re-download the .zip from Github
 
 # ebuild /your/private/o.../python-sage-flint-20140310.ebuild manifest
 
 # emerge dev-python/python-sage-flint
 
 
Without portage:
 # python2 ./setup.py install
 
 if sage include not found, read comments in setup.py, then
 
 # MY_SAGE_IS_HERE=... EPREFIX=... python2 ./setup.py install

If you feel like optimizing, prepend compiler options:

 # CFLAGS='-O2 ... ' MY_SAGE_IS_HERE=... EPREFIX=... python2 ./setup.py install


Two files are installed: flint_sage.so and FLINT_...egg-info. With portage, documentation (this file) will be installed, too.

Note that setup.py script re-creates file nmod_mat_HNF.c even though the latter is included into .zip. This is feature and not a bug.


Test
====

Any of test_*.py script should say something like 'test passed'


FAQ
===

Q0. What are the technical requirements of the package?
A0. GMP, Sage, 64-bit platform, Python ver.2.x; GMP should define mp_limb_t to be unsigned long.

    Use of MPIR instead of GMP might be possible, try this at your own risk.
    
    Why 64-bit? Because I did not test 32-bit installation of Sage or GMP, and have no plans to do so.

    Why Python2? Because I have not tested flint_sage on Python3. I doubt that it will work faster under Python3.
    
    flint_sage is about speed, rather than complete support for everything or your convenience

Q1. Why Sage library is required?
A1. Because mpz_t number need to be converted to/from a Python int, and plain Python does not support this. Therefore some Python wrapper for GMP library like gmpy, pycddlib or Sage required

Q2. Your binding to fmpq_mat is ugly
     f=flint_sage.fmpq_mat( (Integer(1), flint_sage.fmpz_mat(s)) )
A2. No, my binding to fmpz_mat and fmpq_mat is beautiful
     mZ=flint_sage.fmpz_mat( m )
     mQ=flint_sage.fmpq_mat( (Integer(1), mZ) )
    Compare with numpy array constructor
     a=numpy.resize( numpy.array( [], dtype=None ), 10 )

Q3. The .zip file contains whole lot of everything, but no documentation for your Python package. Where do I find useful information about what functions are available and how to call them?
A3. Ha, you just answered your question yourself. .py files (such as test_*.py and benchmark*.py) are samples/demo/test and .cout are captured output of relevant .py files (for instance benchmark_solve_right.cout is what benchmark_solve_right.py output on my desktop)

Q4. Your Python interface is disorganized and inconsistent. Your files are a mess.
A4. However, I am coming near to my mid-range target of modding W.Stein double-det algorithm. My implementation outruns
his.

Q5. What is the meaning of words `... and instructed to use faster low-level routines like FLINT Dixon lifting instead of ?slower? Sage method'?
A5. Good question. I meant to say that 
     1) I re-implemented the Stein algorithm;
     2) in my implemetation, the biggest change is using subroutines thought to be  faster, one of replacements: .solve_right() -> FLINT Dixon linear solver fmpq_mat_solve_dixon();
     3) I think the speed difference between Stein's and my implementation (as published 22-23 Mar 2014) mostly depends on FLINT fmpq_mat_solve_dixon() being faster or slower than Sage subroutine;
     4) I think that fmpq_mat_solve_dixon() is faster than Sage solve_right() on big random matrice in most cases.

 If you want to verify statements 1-4), go for it. Note that I failed to run benchmark for 4000x4000 matrice with entries in range -128..128 on 16G RAM (and succeeded for dim=3000).

 And yes, I am 100% sure that words re-implement and bug-report contain hyphen
