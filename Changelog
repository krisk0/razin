10 Mar 2014  Fixed bugs in unimodular.{4,5}way.py, which resulted in
              incorrect test results or abnormal termination

             Fredrik Johansson, thanks for help. 
             
             The secret method _clean_cache() is really hard to find.

20140312-r0 flint.pyx, class fmpz_mat:
             wrapped fmpz_mat_solve() as solve_right(); 
             added __richcmp__()
            
            benchmark_solve_right.py: benchmarked solve_right() in flint_sage 
             and Sage
            
            Anybody feels like implementing a good interface to Dixon method? 
            Question answered, thanks Fredrick

20140313-r1: fmpq_mat constructor workin

20140314-r0: Some fmpq_mat methods wrapped. benchmark_Dixon_square.py 
             terminated. Sage .inverse() is a winner for matrix larger than 170

15 Mar 2014  Spent few hours wrapping methods nmod_mat_

             Tests show that nmod_mat_rref does not preserve matrice 
              determinant, and nmod_mat_lu* malfunction for non-prime moduli
              
             So how do I count HNF over ring? Do I need to use NTL HNF? 
             
             I wonder what fmpz_mat_fflu, fmpz_mat_rref, 
              fmpz_mat_rref_fraction_free do

17 Mar 2014  Invented ?new? algorithm to compute HNF modulo small number, 
              implemented it. C code (cleaned from debug statements) is 318 
              lines long. The subroutine turned to be slower than its analog 
              in Sage

20140318-r0  Corrected documentation on fmpz_mat_hermite_form() and 
              nmod_mat_HNF() interface

20140318-r1  my modular HNF is at least 2.35 times faster than Sage method doing 
              the same (ratio depends on dimension). See file 
              benchmark_nmod_mat_HNF-sage.cout
             
20140319-r0  the fastest in galaxy C code to count HNF modulo lattice slightly 
              cleaned and now contains 402 lines including 17 assert lines

             nmod_mat_HNF() interface changed: this subroutine returns 0 iff 
              determinant confirmed. This is last interface change for this 
              subroutine. 
              
             I mean it. Really last last change of the interface.

19 Mar 2014 NTL HNF benchmarked. Guess who wins?

20 Mar 2014 wrapped fmpz_mat_fflu, tried it on small matrice

            Looks like this function correctly counts determinant

22 Mar 2014 re-implemented W.Stein double-determinant algorithm using faster
             subroutines including Dixon linear solver and my modular HNF

            The new subroutine is faster than Sage. For instance
             n=100 bits=256 max time sage/mine=2.91527295113/2.11966109276

24 Mar 2014 Dixon is sometimes faster and sometimes slower, only in add_column().
            In double_det() it is faster always. Profiling takes time... 

27 Mar 2014 Equilibrium found, final version of profile_Sage_hnf_square.py is
             running

28 Mar 2014 Profile/Benchmark failed due to bug (exception at line 
             'x[i,0] = x[i,0]/d')            
            Will record the matrice that causes the bug and report it to Sage 
             devs

28 Mar 2014 Sage is playing tricks on me. The exception only occured once, and 
             I did not record the matrice. I restared my program with same
             random generator seed, but the exception did not show up.
             
            Specialized re-implemented hnf_square() runs faster than original, 
             30% faster for n=500, bits=512, 13% faster for n=3000, bits=8

03 Apr 2014 riddle `what is this code doing' partially solved
            3 lines 
             rhs = a_prime - (w * x)[0]    # row-by-col multiplication
             alpha = rhs / lhs             # integer division
             x=x + alpha*k                 # vector add-mul
            take more than 4 seconds on average when source matrice (on input 
             to HNF_square()) is random with n=2000, bits=8

04 Apr 2014 tmod_mat now not only finds LU decomposition (if it exists), but
             also is capable of inverting the two matrix L,U

06 Apr 2014 while random_matrix(ZZ, dim, dim, algorithm='unimodular') takes 
             nearly forever for dim=100, my computation of PLU modulo 2**64 
             and subsequent inversion of it is so fast that it does not make 
             sense to make it faster (gains in speed of HNF computation will 
             be unnoticed).

08 Apr 2014 experimenting with different versions of MPIR/GMP, safely, in 
             lmonade prefixed environment.
             
            My idea was to benchmark integer arithmetic. However, flint-2.4.3 
             test failed under gmp 6.0.0. Need to further investigate this,
             before doing benchmarks

09 Apr 2014 The error is harmless --- I don't plan to check if smth is 
             invertible modulo 1, so hopefully it should not be a problem if
             I choose to switch to linking FLINT to GMP 6.0.0
             
            Linking flint_sage to MPIR turned to be harder than I thought 
             before, due to bugs in gcc/ld behavior. gcc contrary to 
             specification links to standard library rather than library in 
             custom directory. After walking around the gcc bug my flint_sage 
             links to two versions of gmp*.so (one from MPIR and one that is 
             used by Sage), and I suspect that code from the 2nd library is used 
             in calculation, which is not what I want.

            Tests show that replacing GMP implementation does not make 
             determinant() or solve_right() faster on my computer (at least for 
             matrice of size 90 with 100-bit entries)

11 Apr 2014 Under GMP 6.0.0a Sage/Flint is a lot faster than under MPIR 2.7.0. 
             Probably everybody except me knows that MPIR is not something to
             be used under Linux. Now I know that, too. MPIR, goodbye.

20140414-r0 New subroutine mod_mat_HNF_nonsquare(matrice,number): matrice can be
             non-square; number should be a divisor of determinant of lattice 
             (rather than multiple). Full spec in C source between func header
             and func body (as usual)

17 Apr 2014 invert upper-triangular integer matrice with small determinant:
             fmpz_triU_small_det_inverse().
            My specialzed procedure is a lot faster than FLINT 
             fmpz_mat_inverse(): 28.5 times for dim=100, 4.9 times for dim=10

18 Apr 2014 Changing measuring procedure makes figures different: 4.5 not 4.9
             times for dim=10. But who cares for this low dim? For big dimension
             the ratio becomes substantially bigger anyway, see 
             test_benchmark_invert_triU-4ways.cout

28 Apr 2014 Included Agrawal-Kayal-Saxena primality test implemented by 袁轶君:
             n_is_prime_AKS()

29 Apr 2014 Fixed errors in AKS() subroutine, by completely re-implementing it.
             袁轶君, thanks for initial version. The code is terribly slow on 
             64-bit primes. I spent many hours on the code and therefore do not
             delete it
