10 Mar 2014  Fixed bugs in unimodular.{4,5}way.py, which resulted in
              incorrect test results or abnormal termination

             Fredrik Johansson, thanks for help. 
             
             The secret method _clean_cache() is really hard to find.

20140312-r0 flint.pyx, class fmpz_mat:
             wrapped fmpz_mat_solve() as solve_right(); 
             added __richcmp__()
            
            benchmark_solve_right.py: benchmarked solve_right() in flint_sage 
             and Sage
            
            Anybody feels like implementing a good interface to Dixon method? 
            Question answered, thanks Fredrick

20140313-r1: fmpq_mat constructor workin

20140314-r0: Some fmpq_mat methods wrapped. benchmark_Dixon_square.py 
             terminated. Sage .inverse() is a winner for matrix larger than 170

15 Mar 2014  Spent few hours wrapping methods nmod_mat_

             Tests show that nmod_mat_rref does not preserve matrice 
              determinant, and nmod_mat_lu* malfunction for non-prime moduli
              
             So how do I count HNF over ring? Do I need to use NTL HNF? 
             
             I wonder what fmpz_mat_fflu, fmpz_mat_rref, 
              fmpz_mat_rref_fraction_free do

17 Mar 2014  Invented ?new? algorithm to compute HNF modulo small number, 
              implemented it. C code (cleaned from debug statements) is 318 
              lines long. The subroutine turned to be slower than its analog 
              in Sage

20140318-r0  Corrected documentation on fmpz_mat_hermite_form() and 
              nmod_mat_HNF() interface

20140318-r1  my modular HNF is at least 2.35 times faster than Sage method doing 
              the same (ratio depends on dimension). See file 
              benchmark_nmod_mat_HNF-sage.cout
             
20140319-r0  the fastest in galaxy C code to count HNF modulo lattice slightly 
              cleaned and now contains 402 lines including 17 assert lines

             nmod_mat_HNF() interface changed: this subroutine returns 0 iff 
              determinant confirmed. This is last interface change for this 
              subroutine. 
              
             I mean it. Really last last change of the interface.

19 Mar 2014 NTL HNF benchmarked. Guess who wins?

20 Mar 2014 wrapped fmpz_mat_fflu, tried it on small matrice

            Looks like this function correctly counts determinant

22 Mar 2014 re-implemented W.Stein double-determinant algorithm using faster
             subroutines including Dixon linear solver and my modular HNF

            The new subroutine is faster than Sage. For instance
             n=100 bits=256 max time sage/mine=2.91527295113/2.11966109276

24 Mar 2014 Dixon is sometimes faster and sometimes slower, only in add_column().
            In double_det() it is faster always. Profiling takes time... 

27 Mar 2014 Equilibrium found, final version of profile_Sage_hnf_square.py is
             running

28 Mar 2014 Profile/Benchmark failed due to bug (exception at line 
             'x[i,0] = x[i,0]/d')            
            Will record the matrice that causes the bug and report it to Sage 
             devs

28 Mar 2014 Sage is playing tricks on me. The exception only occured once, and 
             I did not record the matrice. I restared my program with same
             random generator seed, but the exception did not show up.
             
            Specialized re-implemented hnf_square() runs faster than original, 
             30% faster for n=500, bits=512, 13% faster for n=3000, bits=8

03 Apr 2014 riddle `what is this code doing' partially solved
            3 lines 
             rhs = a_prime - (w * x)[0]    # row-by-col multiplication
             alpha = rhs / lhs             # integer division
             x=x + alpha*k                 # vector add-mul
            take more than 4 seconds on average when source matrice (on input 
             to HNF_square()) is random with n=2000, bits=8
